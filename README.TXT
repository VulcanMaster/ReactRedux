1. Why Redux?
    - One Store
    - Reduce Boilerplate 
    - Isomorphic/Universal Friendly
    - Immutable Store
    - Hot reloading
    - Time-travel debugging
    - Small

2. Setup environment.
    - #JavaScriptFatigue

3. Added all configuttion files to use during development.

4. cmd: npm start -s
    What this does? 
        - Run the "Start" script point from package.json, the code snippet
            "scripts": {
                "start": "babel-node tools/srcServer.js"
                },
    
    Expected result: The web page of index.html in the browser.

5. Added lint. Cmd to check: npm run lint

6. Added test. Cmd to run: npm test

7. ES6, the difference from ES5
    - No autobind
        * binding directly for compoment
            <div onClick={this.handleClick.bind(this)}</div>
        
        * binding with using the constructor
            constructor(props){
                super(props);
                this.handleClick = this.handleClick.bind(this);
            }

    - PropTypes declared separately
    - Default props declared separately
    - Set initial state in constructor
    - Recommended use "const" instead of "var"
        const HelloWorld = (props) => {
            return (
                <h1> Hello World</h1>
            );
        };
    - Stateless component usage.

7. Container and Presentation react components.
    - Container:
        * Little to no markup
        * Pass data and actions down
        * Knows about Redux
        * Often stateful
            or in jargon
        * Smart
        * Stateful
        * Controller View
        -- Cares about:
            * Focus on how things work
            * Aware of Redux
            * Suscribe to Redux State
            * Dispatch Redux actions
            * Generated by react-redux


    - Presentation:
        * Nearly all markup
        * Receive data and actions via props
        * Doesn`t know about Redux
        *  Typically functional components
            or in jargon
        * Dumb
        * Stateless
        * View
        -- Cares about
            * Focues on how things look
            * Unaware of Redux
            * Read data from props
            * Invoke callbacks on props
            * Written by hand


8. Redux. When do I need Redux?
    - Complex data flow
    - Inter-component communication
    - Non-hierarchical data
    - Many actions
    - Same data used in multiple places

9. Redux foundation principles:
    - One immutable Store
    - Action trigger changes
    - Reducers return update state

    Redux: New Concepts.
        * Reducers - functions
        * Containers - container controllers
        * Immutability - one store and this is  immutable


10. Actions, Store, and Reducers.

    * Action Creators
        rateCourse(rating) {
            return {type: RATE_COUURSE, rating: rating}
        }

        - Where the 
            {type: RATE_COUURSE, rating: rating}
                is the Action

    * Store
        let store = createStore(reducer);

        - by convention the store is able to:
            * store.dispatch(action) - dispathing the action
            * store.subscribe(listener) - suscribe to a listener
            * store.getState() - returns the current state
            * replaceReducer(nextReducer)

11. What is Reducer?

        function myReducer(state, action){
            swithc (action.type){
                case `INCREMENT_COUNTER`:
                return (Object.assign(
                    {},  // create a new empty object
                    state,  // change the state 
                    {counter: state.counter + 1}  // what will be assigned
                ));
            }
        }

12. Forbidden in Reducers:
    - Mutable arguments, i.e. direct state assignment, the assign only with "Object.assign"
    - Perform side effects
    - Call non-pure function, i.e. not use  now, map, random.

13. React-Redux.
        - Provider
            * Attch app to store
                <Provider store={this.props.store}>
                    <App />
                </Provider>

        - Connect
            * Creates container component, i.e. connect component to store
                --  Wraps our compoment so it`s connected to the Redux store.


                    export default connect(
                        mapStateToProps,
                        mapDispatchToProps
                    )(AuthorPage);

                    "mapStateToProps" discribes what states should be followed
                    function mapStateToProps(state, ownProps){
                        return {appState: state.authorReducer} // this examle allow to follow all the states of an app, every any change will call this
                    }

                    "mapDispatchToProps" is describing what actions do I want on props?
                    function mapDispatchToProps(dispatch) {
                        return {
                            actions: bindActionCreators(actions, dispatch)
                        };
                    }

14. A Chat with Redux
    - React: Sombody clicked "Save Course";
    - Action: Thanks React! I will dispatch an action so reducers that care can update state;
    - Reducers: Ah, thanks Action. I see you passed me the current state and the action to perform. I`ll make new copy of state and return it;
    - Store: Thanks for updating the state reducer. I`ll make sure that all connected components are aware;
    - React-Redux: Woah, thanks for the new data Mr.Store. I`ll now intelligently determine if I should tell React about this change so that it onlu has bother with updating the UI when necessary;
    - React: Ooo! Shiny new data has been passed down via props from the store! I`ll update the UI to reflect this!



